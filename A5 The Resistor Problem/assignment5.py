# # -*- coding: utf-8 -*-
# """Assignment5.ipynb

# Automatically generated by Colaboratory.

# Original file is located at
#     https://colab.research.google.com/drive/1OEAQM_vk8AzN5jV5rLKXCZWuODxfwuWV
# """

# #Import the libraries
# from pylab import *
# import mpl_toolkits.mplot3d.axes3d as p3
# import numpy as np
# from scipy.linalg import lstsq

# if(len(sys.argv)==5):#use inputs provided by the user
#   Nx=int(sys.argv[1])
#   Ny=int(sys.argv[2])
#   radius=int(sys.argv[3])  
#   Niter=int(sys.argv[4])
# else:#Default Parameters
#   Nx=25; # size along x
#   Ny=25; # size along y
#   radius=8;# radius of central lead
#   Niter=1500; # number of iterations to perform

# #Allocate the potential array and initialize it
# phi = np.zeros((Ny,Nx))

# x = np.linspace(-0.5,0.5,Nx)
# y = np.linspace(-0.5,0.5,Ny)
# Y,X = np.meshgrid(y,x)

# ii = np.where(X*X+Y*Y<=(radius/25)*(radius/25))
# phi[ii] = 1.0

# contour(range(25),range(25),phi)
# plot(ii[0],ii[1],"ro")
# xlabel(r'x$\rightarrow$',fontsize=15)
# ylabel(r'y$\rightarrow$',fontsize=15)
# title('Potential Contour plot')
# savefig('fig0.png')
# show()

# #Perform the iteration
# #Updating the Potential
# #Vectorizing For Loops
# #Boundary Conditions
# errors = np.zeros(Niter)
# for k in range(Niter):
#   oldphi = phi.copy()
#   phi[1:-1,1:-1]=0.25*(phi[1:-1,0:-2]+phi[1:-1,2:]+phi[0:-2,1:-1]+phi[2:,1:-1])
#   phi[1:-1,0]=phi[1:-1,1]#left
#   phi[1:-1,Nx-1]=phi[1:-1,Nx-2]#right
#   phi[0,1:-1]=phi[1,1:-1]#top
#   phi[ii]=1.0
#   errors[k]=(abs(phi-oldphi)).max()

# #Graphing the results

# semilogy(range(1,Niter+1),errors)
# title("Error on a semilog plot")
# xlabel("No of iterations")
# ylabel("Error")
# savefig('fig1.png')
# show()

# loglog((np.array(range(Niter))+1),errors)
# loglog((np.array(range(Niter))+1)[::50],errors[::50],'ro')
# legend(["for all iterations","for every 50th iteration"])
# title("Error on a loglog plot")
# xlabel("No of iterations")
# ylabel("Error")
# savefig('fig2.png')
# show()

# #Fitting the error
# log_1A , B1 = lstsq(c_[np.ones(Niter),np.array(range(1,Niter+1))],log(errors))[0]
# A1 = exp(log_1A)
# log_500A , B500 = lstsq(c_[np.ones(Niter),np.array(range(1,Niter+1))][500:],log(errors)[500:])[0]
# A500 = exp(log_500A)
# semilogy(range(1,Niter+1),errors,'k', label= 'errors')
# semilogy(range(1,Niter+1,50),A1*(exp(B1*np.array(range(1,Niter+1,50)))), 'ro',label = 'fit1')
# semilogy(range(500,Niter+1,50),A500*(exp(B500*np.array(range(500,Niter+1,50)))), 'go',label = 'fit2')
# title("best fit Error on a semilog plot using least squares")
# xlabel("No of iterations")
# ylabel("Error")
# legend()
# savefig('fig3.png')
# show()

# #Cummulative Error
# loglog(range(100,Niter+1,50),(-A500/B500)*exp(B500*(np.array(range(100,Niter+1,50))+0.5)),'ro')
# title("Cummulative error values")
# xlabel("iterations")
# ylabel("maximum error")
# grid(True)
# savefig('fig4.png')
# show()

# #Surface Plot of Potential
# fig1=figure(4) # open a new figure
# ax=p3.Axes3D(fig1) # Axes3D is the means to do a surface plot
# title('The 3-D surface plot of the potential')
# surf = ax.plot_surface(Y, X, phi.T, rstride=1, cstride=1, cmap=cm.jet)
# savefig('fig5.png')

# #Contour Plot of the Potential
# contour(range(Nx),range(Ny),phi)
# plot(ii[0],ii[1],"ro")
# xlabel(r'x$\rightarrow$',fontsize=15)
# ylabel(r'y$\rightarrow$',fontsize=15)
# title('Potential Contour plot')
# savefig('fig6.png')
# show()

# #Vector Plot of Currents
# Jx = np.zeros((Ny,Nx))
# Jy = np.zeros((Ny,Nx))
# Jx[0:,1:-1]=0.5*(phi[0:,0:-2]-phi[0:,2:])
# Jy[1:-1,0:]=0.5*(phi[0:-2,0:]-phi[2:,0:])
# plot(ii[0],ii[1],"ro")
# quiver(range(Nx),range(Ny),-Jx[::-1,:],-Jy[::-1,:])
# title("vector plot of current flow")
# savefig('fig7.png')
# show()


#include <bits/stdc++.h>
using namespace std;

int main()
{
    int T,t=1;
    cin>>T;
    while(T>=t)
    {
        cout<<"Case #"<<t<<": ";
        t++;
        int N,k=0;
        cin>>N;
        
        int F[N],P[N];
        for(int i=0;i<N;i++)
        cin>>F[i];
        for(int i=0;i<N;i++)
        cin>>P[i];
        
        sort(S,S+N);
        
        for(int i=0;i<N;i++)
        {
            if(S[i]>k)
            {
                k++;
            }
        }
        cout<<k<<endl;
    }
    return 0;
}